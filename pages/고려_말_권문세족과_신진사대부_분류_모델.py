# -*- coding: utf-8 -*-
"""고려 말 권문세족과 신진사대부 분류 모델.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1FU6k7uTDS2t0mwe-ENWFkomn61_9d3u1
"""

pip install google-generativeai

import google.generativeai as genai
import os
import streamlit as st  # 이 줄이 없으면 맨 위에 추가해주세요!

# 이제 실제 키 대신 '비밀 금고'를 참조합니다
GOOGLE_API_KEY = st.secrets["GEMINI_API_KEY"]
genai.configure(api_key=GOOGLE_API_KEY)


# ---------------------------------------------------------
# 2. 모델 설정 (Gemini Pro 사용)
# ---------------------------------------------------------
# 역사적 사실 분석에 적합한 설정을 적용합니다.
generation_config = {
    "temperature": 0.2,  # 사실 기반 답변을 위해 창의성(temperature)을 낮춤
    "top_p": 1,
    "top_k": 32,
    "max_output_tokens": 1024,
}

model = genai.GenerativeModel(
    model_name="gemini-2.5-flash", # 또는 gemini-1.5-pro
    generation_config=generation_config
)

def classify_historical_figure(name):
    """
    입력된 인물이 고려 말 권문세족인지 신진사대부인지 분류하고 근거를 제시하는 함수
    """

    # 시스템 프롬프트: 모델에게 역사학자 페르소나와 분류 기준을 부여
    prompt = f"""
    당신은 한국사, 특히 고려 말기 정치사에 정통한 역사학자입니다.
    사용자가 입력한 역사적 인물 '{name}'에 대해 다음 작업을 수행하세요.

    1. **분류 (Classification)**: 이 인물이 '권문세족(Gwonmun Sejok)'과 '신진사대부(Sinjin Sadaebu)' 중 어디에 속하는지, 혹은 그 경계에 있거나 어느 쪽에도 속하지 않는지 명확히 분류하세요.
    2. **핵심 근거 (Reasoning)**:
       - 출신 가문 (음서제 활용 여부 vs 지방 향리/과거 급제)
       - 정치적 성향 (친원 vs 친명, 불교 옹호 vs 성리학 수용)
       - 경제적 기반 (대농장 소유 vs 과전법 지지)
       - 주요 행적을 바탕으로 분류의 이유를 3가지 이상 항목별로 설명하세요.

    출력 형식:
    ---
    **인물:** {name}
    **분류:** [권문세족 / 신진사대부 / 기타]

    **판단 근거:**
    1. [근거 1]
    2. [근거 2]
    3. [근거 3]

    **종합 의견:**
    [한 줄 요약]
    ---
    """

    try:
        # API 호출 및 응답 생성
        response = model.generate_content(prompt)
        return response.text
    except Exception as e:
        return f"에러가 발생했습니다: {str(e)}"

# ---------------------------------------------------------
# 3. 메인 실행부
# ---------------------------------------------------------
if __name__ == "__main__":
    print("=== 고려 말 인물 분류기 (Powered by Google Gemini) ===")
    print("분석하고 싶은 고려 말 인물의 이름을 입력하세요. (종료하려면 'q' 입력)")

    while True:
        user_input = input("\n인물 이름 입력: ").strip()

        if user_input.lower() == 'q':
            print("프로그램을 종료합니다.")
            break

        if not user_input:
            print("이름을 입력해주세요.")
            continue

        print(f"\n'{user_input}'에 대해 분석 중입니다...\n")
        result = classify_historical_figure(user_input)
        print(result)

import requests
from bs4 import BeautifulSoup
import google.generativeai as genai
import urllib.parse

# =========================================================
# 1. API 설정 (여기에 발급받은 키를 입력하세요)
# =========================================================
API_KEY = "AIzaSyBEmAHr7r1i2mt8yu6qjp3P79ErIfQrIfw"
genai.configure(api_key=API_KEY)

# 모델 설정
model = genai.GenerativeModel("gemini-2.5-flash") # 속도와 효율성을 위해 Flash 모델 권장

# =========================================================
# 2. 한국사데이터베이스 웹 스크래핑 함수
# =========================================================
def scrape_history_db(name):
    """
    한국사데이터베이스(db.history.go.kr) 통합검색에서
    해당 인물에 대한 검색 결과 텍스트를 수집합니다.
    """
    print(f"[*] 한국사데이터베이스에서 '{name}' 관련 자료를 검색 중입니다...")

    # URL 인코딩 (한글 이름을 URL로 변환)
    encoded_name = urllib.parse.quote(name)

    # 한국사DB 통합검색 URL (구조가 변경될 경우 수정이 필요할 수 있습니다)
    url = f"https://db.history.go.kr/integrated/search/searchResult.do?keyword={encoded_name}&sortType=s&searchType=s"

    # 봇 차단을 방지하기 위한 헤더 설정
    headers = {
        "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36"
    }

    try:
        response = requests.get(url, headers=headers)
        response.raise_for_status() # 200 OK가 아니면 에러 발생

        soup = BeautifulSoup(response.text, 'html.parser')

        # 검색 결과에서 텍스트 추출
        # 사이트 구조상 검색 결과 리스트는 주로 'ul.result_list' 안에 있거나 'dl' 태그 등으로 구성됨
        # 여기서는 범용성을 위해 검색 결과 영역의 텍스트를 긁어옵니다.

        # 데이터가 포함된 주요 컨테이너 찾기 (사이트 구조 분석 기반)
        content_area = soup.find('div', {'class': 'cont_view'})

        if not content_area:
            # 컨테이너를 못 찾으면 전체 body에서 텍스트 추출 (Fallback)
            content_area = soup.body

        # 텍스트 정제 (공백 제거 및 리스트화)
        extracted_text = content_area.get_text(strip=True)[:3000] # 너무 길면 토큰 제한 걸리므로 앞부분 3000자만 사용

        if len(extracted_text) < 50:
            return None # 검색 결과가 너무 적거나 없을 경우

        return extracted_text

    except Exception as e:
        print(f"[!] 스크래핑 중 에러 발생: {e}")
        return None

# =========================================================
# 3. Gemini를 이용한 분류 및 분석 함수
# =========================================================
def classify_with_gemini(name, scraped_data):
    """
    스크래핑한 데이터를 문맥으로 제공하여 인물을 분류합니다.
    """
    if not scraped_data:
        context_msg = "한국사데이터베이스에서 직접적인 사료를 찾지 못했습니다. 당신의 배경지식을 활용하세요."
    else:
        context_msg = f"다음은 한국사데이터베이스에서 발췌한 '{name}' 관련 검색 결과입니다:\n{scraped_data}\n"

    # 프롬프트 작성
    prompt = f"""
    {context_msg}

    위의 정보(혹은 당신의 지식)를 바탕으로 고려 말 인물 '{name}'을 분석해주세요.

    [임무]
    1. 이 인물을 **'권문세족'** 또는 **'신진사대부'** 중 하나로 분류하세요. (애매할 경우 어느 쪽에 더 가까운지 명시)
    2. 그 이유를 다음 3가지 측면에서 설명하세요:
       - **가문 배경** (음서 vs 과거)
       - **정치/경제적 기반** (대농장 vs 과전법, 친원 vs 친명)
       - **주요 행적**
    3. 반드시 제공된 사료(스크래핑 데이터)에 언급된 내용이 있다면 인용하여 근거를 강화하세요.

    [출력 형식]
    **인물:** {name}
    **결과:** [권문세족 / 신진사대부]
    **근거:**
    1. ...
    2. ...
    **사료 기반 참조:** (스크래핑된 데이터에서 발견된 관련 키워드나 사건 언급)
    """

    response = model.generate_content(prompt)
    return response.text

# =========================================================
# 4. 메인 실행
# =========================================================
if __name__ == "__main__":
    print("--- 고려 말 인물 분류기 (Web Scraping + AI) ---")

    while True:
        target_name = input("\n인물 이름을 입력하세요 (종료: q): ").strip()
        if target_name.lower() == 'q':
            break

        if not target_name:
            continue

        # 1. 웹 스크래핑
        scraped_text = scrape_history_db(target_name)

        if scraped_text:
            print(f"[*] '{target_name}' 관련 데이터를 성공적으로 수집했습니다. 분석을 시작합니다...")
        else:
            print(f"[!] '{target_name}' 관련 데이터를 웹에서 찾지 못했습니다. AI의 기본 지식으로 분석합니다...")

        # 2. AI 분석
        result = classify_with_gemini(target_name, scraped_text)

        # 결과 출력
        print("\n" + "="*50)
        print(result)
        print("="*50)
